<html>
  <head>
    <script src="https://unpkg.com/three@0.120.1/build/three.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
      }

      canvas {
        position: absolute;
        height: 100%;
        width: 100%;
      }
      
      p {
        color: white;
        left: 50px;
        position: absolute;
        top: 10px;
        z-index: 9999;
      }
    </style>
  </head>
  <body>
    <canvas></canvas>
    <p>This is a <a href="https://google.com">link</a>.</p>
  <script>
    const floorSize = 50;
    const size = 15;

    function createBox(color) {
      var geometry = new THREE.BoxGeometry();
      var material = new THREE.MeshStandardMaterial( { color } );
      const mesh = new THREE.Mesh( geometry, material );
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      return mesh;
    }

    function createFloor() {
      var geometry = new THREE.BoxGeometry(floorSize, 1, floorSize);
      var material = new THREE.MeshStandardMaterial( { color: 0xffffff } );
      const mesh = new THREE.Mesh( geometry, material );
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      return mesh;
    }

    const loader = new THREE.TextureLoader();

    const scene = new THREE.Scene();
    const fogColor = new THREE.Color(0x302860);
    scene.background = fogColor;
    // scene.fog = new THREE.FogExp2(fogColor, 0.05);

    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

    const createWall = (texture, alphaTexture) => {
      const material = new THREE.MeshStandardMaterial({
        map: texture,
        opacity: 1,
        transparent: true,
      });

      var customDistanceMaterial = new THREE.MeshDistanceMaterial({
        alphaMap: alphaTexture,
        alphaTest: 0.5,
      });

      const geometry = new THREE.BoxGeometry(size, size, 0);
      const wall = new THREE.Mesh( geometry, material );
      wall.position.z = - size / 2;
      wall.position.y = (size / 2) - 2;
      wall.castShadow = true;
      wall.receiveShadow = true;
      wall.customDistanceMaterial = customDistanceMaterial;
      scene.add(wall);
    }

    const errorHandler = (err) => { console.error(err) };

    loader.load(
      'arvores_transparente.png',
      (texture) => {
        loader.load('alpha_test.png', (alphaTexture) => createWall(texture, alphaTexture), null, errorHandler)
      },
      null,
      errorHandler
    );

    var renderer = new THREE.WebGLRenderer({
      canvas: document.querySelector('canvas')
    });
    renderer.shadowMap.enabled = true;
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    const floor = createFloor()
    floor.position.y = -2;
    scene.add(floor);

    const yellow = createBox(0xffff00);
    scene.add(yellow);
    yellow.position.z = - size;

    const green = createBox(0x00ff00);
    scene.add(green);

    const red = createBox(0xff0000);
    scene.add(red);

    const blue = createBox(0x0000ff);
    scene.add(blue);

    var light = new THREE.PointLight( 0xffffff, 5, 30 );
    light.position.set(5, 15, -5);
    light.castShadow = true;
    light.shadow.mapSize.width = 1024;
    light.shadow.mapSize.height = 1024;
    light.shadow.camera.near = 1;
    light.shadow.camera.far = 100;
    light.shadow.radius = 5;
    scene.add( light );

    camera.position.x = 10;
    camera.position.y = 5;
    camera.position.z = 0;

    camera.lookAt(floor.position);

    let t = 0;
    const r = 2;
    let selectedBox = blue;
    function animate() {
      requestAnimationFrame( animate );
      t += 0.01;

      green.position.x = Math.sin(t) * r;
      green.position.z = Math.cos(t) * r;

      red.position.x = Math.sin(t + Math.PI * 1 / 3) * r;
      red.position.z = Math.cos(t + Math.PI * 1 / 3) * r;

      blue.position.x = Math.sin(t + Math.PI * 2 / 3) * r;
      blue.position.z = Math.cos(t + Math.PI * 2 / 3) * r;

      yellow.position.y = 2 + Math.sin(t + Math.PI * 2 / 3) * r;
      yellow.position.z = - size + 3 * Math.cos(t + Math.PI * 2 / 3) * r;

      camera.lookAt(yellow.position);

      renderer.render( scene, camera );
    }
    animate();
  </script>
  </body>
</html>